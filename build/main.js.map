{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport ChannelDetector, { type ExternalDetectorState, type Types } from '@iobroker/type-detector';\n\ntype DeviceDefinition = {\n\tstates: ExternalDetectorState[];\n\ttype: Types;\n\tenumRequired?: boolean;\n\tname: string;\n};\n\ntype StateWithDeviceRef = ExternalDetectorState & {\n\tdeviceRef: DeviceDefinition;\n};\n\ntype StateCreationJob = ExternalDetectorState & {\n\tfqStateName: string;\n\tcommonType: ioBroker.CommonType;\n};\n\nconst getDeviceMetadata: () => DeviceDefinition[] = () => {\n\tconst knownPatterns = ChannelDetector.getPatterns();\n\n\treturn Object.entries(knownPatterns).map(([k, v]) => ({\n\t\t...v,\n\t\tstates: v.states.filter(s => !!s.defaultRole),\n\t\tname: k,\n\t}));\n};\n\nconst getStateType = (state: ExternalDetectorState, fallback?: ioBroker.CommonType): ioBroker.CommonType => {\n\treturn Array.isArray(state.type) ? state.type[0] : (state.type ?? fallback ?? 'string');\n};\n\nconst printMissingDefaultRoleMarkdown = (states: StateWithDeviceRef[]): void => {\n\tconst sortedStates = [...states] // Assuming sort is stable.\n\t\t.sort((a, b) => a.name.localeCompare(b.name))\n\t\t.sort((a, b) => a.deviceRef.name.localeCompare(b.deviceRef.name));\n\n\tlet output = '| Device | Name | Type | Role Regex |\\n';\n\toutput += '| - | - | - | - |\\n';\n\n\t/*                                                                                   *caugh* */\n\tfor (const state of sortedStates) {\n\t\toutput += `| ${state.deviceRef.name} | ${state.name} | ${getStateType(state, 'N/A' as any)} | \\`${state.role}\\` |\\n`;\n\t}\n\n\tconsole.log(output);\n};\n\nclass TestDevices extends utils.Adapter {\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: 'test-devices',\n\t\t});\n\t\tthis.on('ready', this.onReady.bind(this));\n\t\tthis.on('unload', this.onUnload.bind(this));\n\t}\n\n\tprivate static deviceFolderName: string = 'devices';\n\tprivate static triggerFolderName: string = 'triggers';\n\n\tpublic static GetDeviceFolderName(): string {\n\t\treturn TestDevices.deviceFolderName;\n\t}\n\n\tpublic static GetTriggerFolderName(): string {\n\t\treturn TestDevices.triggerFolderName;\n\t}\n\n\tprivate async onReady(): Promise<void> {\n\t\tconst allDevices = getDeviceMetadata();\n\n\t\tthis.analyzeAllStates(allDevices);\n\n\t\tconst deviceNamesWithMissingDefaultRoles = this.getDeviceNamesMissingDefaultRoles(allDevices);\n\t\tthis.analyzeDuplicateDefaultRoles(allDevices);\n\n\t\tconst validDevices: DeviceDefinition[] = allDevices.filter(\n\t\t\td => !deviceNamesWithMissingDefaultRoles.includes(d.name),\n\t\t);\n\n\t\tawait this.createTopLevelFoldersAsync();\n\n\t\tthis.log.info(`Creating states for ${validDevices.length} devices`);\n\n\t\tlet createdStates = 0;\n\t\tconst startMs = Date.now();\n\t\tfor (const device of validDevices) {\n\t\t\tcreatedStates += await this.createOrUpdateSingleDeviceAsync(\n\t\t\t\tdevice,\n\t\t\t\tTestDevices.GetDeviceFolderName(),\n\t\t\t\t'required',\n\t\t\t\ts => !!s.required,\n\t\t\t);\n\t\t\tcreatedStates += await this.createOrUpdateSingleDeviceAsync(\n\t\t\t\tdevice,\n\t\t\t\tTestDevices.GetDeviceFolderName(),\n\t\t\t\t'all',\n\t\t\t\t_ => true,\n\t\t\t);\n\t\t}\n\n\t\tthis.log.info(\n\t\t\t`Done. Created ${createdStates} states for ${validDevices.length} devices in ${Date.now() - startMs}ms.`,\n\t\t);\n\t}\n\n\tprivate async createTopLevelFoldersAsync(): Promise<void> {\n\t\tconst fqFolderName = `${this.namespace}.${TestDevices.GetDeviceFolderName()}`;\n\t\tconst fqTriggerName = `${this.namespace}.${TestDevices.GetTriggerFolderName()}`;\n\n\t\tawait Promise.allSettled([\n\t\t\tthis.extendObject(fqTriggerName, {\n\t\t\t\ttype: 'folder',\n\t\t\t\tcommon: {\n\t\t\t\t\tname: fqTriggerName,\n\t\t\t\t},\n\t\t\t}),\n\t\t\tthis.extendObject(fqFolderName, {\n\t\t\t\ttype: 'folder',\n\t\t\t\tcommon: {\n\t\t\t\t\tname: fqFolderName,\n\t\t\t\t},\n\t\t\t}),\n\t\t]);\n\t}\n\n\tprivate async createOrUpdateSingleDeviceAsync(\n\t\tdevice: DeviceDefinition,\n\t\tfolderName: string,\n\t\tprefix: string,\n\t\tstateFilter: (state: ExternalDetectorState) => boolean,\n\t): Promise<number> {\n\t\tconst deviceType = `${this.namespace}.${folderName}.${prefix}`;\n\t\tawait this.extendObject(deviceType, {\n\t\t\ttype: 'device',\n\t\t\tcommon: {\n\t\t\t\tname: device.name,\n\t\t\t},\n\t\t});\n\n\t\tconst deviceRoot = `${deviceType}.${device.name}`;\n\t\tawait this.extendObject(deviceType, {\n\t\t\ttype: 'channel',\n\t\t\tcommon: {\n\t\t\t\tname: deviceRoot,\n\t\t\t},\n\t\t});\n\n\t\tconst mapStateToJob: (s: ExternalDetectorState) => StateCreationJob = s => {\n\t\t\treturn {\n\t\t\t\t...s,\n\t\t\t\tfqStateName: `${deviceRoot}.${s.name}`,\n\t\t\t\tcommonType: getStateType(s),\n\t\t\t};\n\t\t};\n\n\t\t// concurrency is limited by the device-iterator in onReady.\n\t\t// semi-limited. Ok, I just don't want to use a queue, leave me alone.\n\t\tconst allPromises = device.states\n\t\t\t.filter(stateFilter)\n\t\t\t.map<StateCreationJob>(mapStateToJob)\n\t\t\t.map(state =>\n\t\t\t\tthis.extendObject(state.fqStateName, {\n\t\t\t\t\ttype: 'state',\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: state.name,\n\t\t\t\t\t\ttype: state.commonType,\n\t\t\t\t\t\tread: state.read ?? true,\n\t\t\t\t\t\twrite: state.write ?? false,\n\t\t\t\t\t\trole: state.defaultRole,\n\t\t\t\t\t\tunit: state.defaultUnit,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\tawait Promise.allSettled(allPromises);\n\n\t\treturn allPromises.length;\n\t}\n\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// nothing to do yet\n\t\t} catch (error) {\n\t\t\tthis.log.error(`Error during unloading: ${(error as Error).message}`);\n\t\t} finally {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\tprivate analyzeAllStates(allDevices: DeviceDefinition[]): void {\n\t\tconst mapState: (device: DeviceDefinition, state: ExternalDetectorState) => StateWithDeviceRef = (\n\t\t\tdevice,\n\t\t\tstate,\n\t\t) => ({ ...state, deviceRef: device });\n\n\t\tconst allStates = allDevices.reduce(\n\t\t\t(prev: StateWithDeviceRef[], curr) => [...prev, ...curr.states.map(s => mapState(curr, s))],\n\t\t\t[],\n\t\t);\n\n\t\tthis.log.info(`State count total: ${allStates.length}`);\n\n\t\tconst statesWithoutDefaultRole = allStates.filter(s => !s.defaultRole);\n\n\t\tif (statesWithoutDefaultRole.length > 0) {\n\t\t\tthis.log.info(\n\t\t\t\t`States without default role: ${statesWithoutDefaultRole.length} - [${statesWithoutDefaultRole.map(s => s.name).join(', ')}]`,\n\t\t\t);\n\n\t\t\tprintMissingDefaultRoleMarkdown(statesWithoutDefaultRole);\n\t\t}\n\t}\n\n\tprivate analyzeDuplicateDefaultRoles(allDevices: DeviceDefinition[]): void {\n\t\tconst isDuplicatedDefaultRole = (state: ExternalDetectorState, allStates: ExternalDetectorState[]): boolean => {\n\t\t\treturn allStates.filter(sInner => sInner.defaultRole == state.defaultRole).length > 1;\n\t\t};\n\n\t\tconst devicesWithDuplicateDefaultRoles = allDevices.filter(\n\t\t\td => d.states.filter(s => isDuplicatedDefaultRole(s, d.states)).length > 0,\n\t\t);\n\n\t\tif (devicesWithDuplicateDefaultRoles.length > 0) {\n\t\t\tconst deviceNamesWithDuplicateDefaultRoles = devicesWithDuplicateDefaultRoles.map(d => d.name);\n\t\t\tthis.log.info(\n\t\t\t\t`Found ${devicesWithDuplicateDefaultRoles.length} devices with duplicate default roles: [${deviceNamesWithDuplicateDefaultRoles.join(\n\t\t\t\t\t', ',\n\t\t\t\t)}] A state will be generated for each, ignoring the duplication.`,\n\t\t\t);\n\n\t\t\tfor (const device of devicesWithDuplicateDefaultRoles) {\n\t\t\t\tconst duplicatedDefaultRoles = device.states\n\t\t\t\t\t.filter(s => isDuplicatedDefaultRole(s, device.states))\n\t\t\t\t\t.map(s => `${s.name} -> ${s.defaultRole}`);\n\n\t\t\t\tthis.log.info(`\\t${device.name} -> Duplicate Roles: ${duplicatedDefaultRoles.join(', ')}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getDeviceNamesMissingDefaultRoles(allDevices: DeviceDefinition[]): string[] {\n\t\tconst devicesWithMissingDefaultRoles = allDevices.filter(\n\t\t\td => d.states.filter(s => s.required && !s.defaultRole).length > 0,\n\t\t);\n\n\t\tconst deviceNamesWithMissingDefaultRoles = devicesWithMissingDefaultRoles.map(d => d.name);\n\n\t\tif (devicesWithMissingDefaultRoles.length > 0) {\n\t\t\tthis.log.warn(\n\t\t\t\t`Found ${devicesWithMissingDefaultRoles.length} devices with missing default roles: [${deviceNamesWithMissingDefaultRoles.join(\n\t\t\t\t\t', ',\n\t\t\t\t)}] These will be skipped.`,\n\t\t\t);\n\t\t}\n\n\t\treturn deviceNamesWithMissingDefaultRoles;\n\t}\n}\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new TestDevices(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new TestDevices())();\n}\n"],
  "mappings": "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",
  "names": ["ChannelDetector"]
}
