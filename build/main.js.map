{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport ChannelDetector, { type ExternalDetectorState, type Types } from '@iobroker/type-detector';\n\ntype DeviceDefinition = {\n\tstates: ExternalDetectorState[];\n\ttype: Types;\n\tenumRequired?: boolean;\n\tname: string;\n};\n\ntype StateWithDeviceRef = ExternalDetectorState & {\n\tdeviceRef: DeviceDefinition;\n};\n\nconst getStateType = (state: ExternalDetectorState, fallback?: ioBroker.CommonType): ioBroker.CommonType => {\n\treturn Array.isArray(state.type) ? state.type[0] : (state.type ?? fallback ?? 'string');\n};\n\nconst printMissingDefaultRoleMarkdown = (states: StateWithDeviceRef[]): void => {\n\tconst sortedStates = [...states] // Assuming sort is stable.\n\t\t.sort((a, b) => a.name.localeCompare(b.name))\n\t\t.sort((a, b) => a.deviceRef.name.localeCompare(b.deviceRef.name));\n\n\tlet output = '| Device | Name | Type | Role Regex |\\n';\n\toutput += '| - | - | - | - |\\n';\n\n\t/*                                                                                   *caugh* */\n\tfor (const state of sortedStates) {\n\t\toutput += `| ${state.deviceRef.name} | ${state.name} | ${getStateType(state, 'N/A' as any)} | \\`${state.role}\\` |\\n`;\n\t}\n\n\tconsole.log(output);\n};\n\nclass TestDevices extends utils.Adapter {\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: 'test-devices',\n\t\t});\n\t\tthis.on('ready', this.onReady.bind(this));\n\t\tthis.on('unload', this.onUnload.bind(this));\n\t}\n\n\tprivate async onReady(): Promise<void> {\n\t\tconst knownPatterns = ChannelDetector.getPatterns();\n\n\t\tconst allDevices = Object.entries(knownPatterns).map(([k, v]) => ({\n\t\t\t...v,\n\t\t\tname: k,\n\t\t}));\n\n\t\tconst mapState: (device: DeviceDefinition, state: ExternalDetectorState) => StateWithDeviceRef = (\n\t\t\tdevice,\n\t\t\tstate,\n\t\t) => ({ ...state, deviceRef: device });\n\n\t\tconst allStates = allDevices.reduce(\n\t\t\t(prev: StateWithDeviceRef[], curr) => [...prev, ...curr.states.map(s => mapState(curr, s))],\n\t\t\t[],\n\t\t);\n\n\t\tthis.log.info(`State count total: ${allStates.length}`);\n\n\t\tconst statesWithoutDefaultRole = allStates.filter(s => !s.defaultRole);\n\n\t\tif (statesWithoutDefaultRole.length > 0) {\n\t\t\tthis.log.info(\n\t\t\t\t`States without default role: ${statesWithoutDefaultRole.length} - [${statesWithoutDefaultRole.map(s => s.name).join(', ')}]`,\n\t\t\t);\n\n\t\t\tprintMissingDefaultRoleMarkdown(statesWithoutDefaultRole);\n\t\t}\n\n\t\tconst devicesWithMissingDefaultRoles = allDevices.filter(\n\t\t\td => d.states.filter(s => s.required && !s.defaultRole).length > 0,\n\t\t);\n\n\t\tconst deviceNamesWithMissingDefaultRoles = devicesWithMissingDefaultRoles.map(d => d.name);\n\n\t\tif (devicesWithMissingDefaultRoles.length > 0) {\n\t\t\tthis.log.warn(\n\t\t\t\t`Found ${devicesWithMissingDefaultRoles.length} devices with missing default roles: [${deviceNamesWithMissingDefaultRoles.join(\n\t\t\t\t\t', ',\n\t\t\t\t)}] These will be skipped.`,\n\t\t\t);\n\t\t}\n\n\t\tconst validDevices: DeviceDefinition[] = allDevices.filter(\n\t\t\td => !deviceNamesWithMissingDefaultRoles.includes(d.name),\n\t\t);\n\n\t\tthis.log.info(`Creating states for ${validDevices.length} devices`);\n\n\t\tlet createdStates = 0;\n\t\tconst startMs = Date.now();\n\t\tfor (const device of validDevices) {\n\t\t\tcreatedStates += await this.createOrUpdateSingleDeviceAsync(device);\n\t\t}\n\n\t\tthis.log.info(\n\t\t\t`Done. Created ${createdStates} states for ${validDevices.length} devices in ${Date.now() - startMs}ms.`,\n\t\t);\n\t}\n\n\tprivate async createOrUpdateSingleDeviceAsync(device: DeviceDefinition): Promise<number> {\n\t\tconst deviceRoot = `${this.namespace}.${device.name}`;\n\t\tawait this.extendObject(deviceRoot, {\n\t\t\ttype: 'channel',\n\t\t\tcommon: {\n\t\t\t\tname: device.name,\n\t\t\t},\n\t\t});\n\n\t\tlet createdStates = 0;\n\t\tfor (const state of device.states.filter(s => s.required)) {\n\t\t\tconst stateName = `${deviceRoot}.${state.name}`;\n\t\t\tconst type = getStateType(state);\n\n\t\t\tawait this.extendObject(stateName, {\n\t\t\t\ttype: 'state',\n\t\t\t\tcommon: {\n\t\t\t\t\tname: state.name,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tread: state.read ?? true,\n\t\t\t\t\twrite: state.write ?? false,\n\t\t\t\t\trole: state.defaultRole,\n\t\t\t\t\tunit: state.defaultUnit,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tcreatedStates++;\n\t\t}\n\n\t\treturn createdStates;\n\t}\n\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// nothing to do yet\n\t\t} catch (error) {\n\t\t\tthis.log.error(`Error during unloading: ${(error as Error).message}`);\n\t\t} finally {\n\t\t\tcallback();\n\t\t}\n\t}\n}\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new TestDevices(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new TestDevices())();\n}\n"],
  "mappings": "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",
  "names": ["ChannelDetector"]
}
