{
  "version": 3,
  "sources": ["../src/state-definitions.ts"],
  "sourcesContent": ["import type { ExternalDetectorState } from '@iobroker/type-detector';\nimport { crossProduct, getStateType } from './utils';\nimport { deviceFilter, generationTypes, GetDeviceFolderName } from './constants';\nimport { getValueGenerator } from './value-generator-factory';\nimport { getFallbackValueGenerator } from './value-generators';\n\nexport const createDesiredStateDefinitions = (\n\tnamespace: string,\n\tconfig: ioBroker.AdapterConfig,\n\tvalidDevices: ioBroker.DeviceDefinition[],\n\ttrackGeneratorCb?: (sd: ioBroker.DeviceStateDefinition, vg: ioBroker.ValueGeneratorDefinition[]) => void,\n): Record<string, ioBroker.DeviceStateDefinition> => {\n\tconst getDeviceType = (genType: ioBroker.DeviceStatesGenerationType): string =>\n\t\t`${namespace}.${GetDeviceFolderName()}.${genType}`;\n\tconst getDeviceRoot = (genType: ioBroker.DeviceStatesGenerationType, device: ioBroker.DeviceDefinition): string =>\n\t\t`${getDeviceType(genType)}.${device.name}`;\n\n\t// 'NoOp' for now\n\tconst getFilterContext = (device: ioBroker.DeviceDefinition): ioBroker.DeviceFilterContext => {\n\t\treturn { device, config: config };\n\t};\n\n\tconst isReadOnly = (state: ExternalDetectorState): boolean =>\n\t\t(!!state.read || state.read === undefined) && !state.write;\n\n\tconst stateCacheMemory: ioBroker.DeviceStateDefinition[] = crossProduct(generationTypes, validDevices)\n\t\t.map(arr => ({\n\t\t\tgenerationType: arr[0],\n\t\t\tdevice: arr[1],\n\t\t}))\n\t\t.map(m => ({\n\t\t\t...m,\n\t\t\tcontext: getFilterContext(m.device),\n\t\t\tdeviceType: getDeviceType(m.generationType),\n\t\t\tdeviceRoot: getDeviceRoot(m.generationType, m.device),\n\t\t}))\n\t\t.map(m =>\n\t\t\tm.device.states\n\t\t\t\t.filter(s => deviceFilter[m.generationType](m.context, s))\n\t\t\t\t.map(s => ({\n\t\t\t\t\t...m,\n\t\t\t\t\tstate: s,\n\t\t\t\t\tread: s.read ?? true,\n\t\t\t\t\twrite: s.write ?? false,\n\t\t\t\t\tstateFqn: `${m.deviceRoot}.${s.name}`,\n\t\t\t\t\tcommonType: getStateType(s),\n\t\t\t\t\tisReadOnly: isReadOnly(s),\n\t\t\t\t\tvalueGenerator: undefined,\n\t\t\t\t})),\n\t\t)\n\t\t.reduce((prev, curr) => [...prev, ...curr], [])\n\t\t.map(sd => ({\n\t\t\t...sd,\n\t\t\tvalueGenerator: getValueGenerator(sd, trackGeneratorCb) ?? getFallbackValueGenerator(),\n\t\t}));\n\n\treturn stateCacheMemory.reduce((prev, curr) => ({ ...prev, [curr.stateFqn]: curr }), {});\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAA2C;AAC3C,uBAAmE;AACnE,qCAAkC;AAClC,8BAA0C;AAEnC,MAAM,gCAAgC,CAC5C,WACA,QACA,cACA,qBACoD;AACpD,QAAM,gBAAgB,CAAC,YACtB,GAAG,SAAS,QAAI,sCAAoB,CAAC,IAAI,OAAO;AACjD,QAAM,gBAAgB,CAAC,SAA8C,WACpE,GAAG,cAAc,OAAO,CAAC,IAAI,OAAO,IAAI;AAGzC,QAAM,mBAAmB,CAAC,WAAoE;AAC7F,WAAO,EAAE,QAAQ,OAAe;AAAA,EACjC;AAEA,QAAM,aAAa,CAAC,WAClB,CAAC,CAAC,MAAM,QAAQ,MAAM,SAAS,WAAc,CAAC,MAAM;AAEtD,QAAM,uBAAqD,2BAAa,kCAAiB,YAAY,EACnG,IAAI,UAAQ;AAAA,IACZ,gBAAgB,IAAI,CAAC;AAAA,IACrB,QAAQ,IAAI,CAAC;AAAA,EACd,EAAE,EACD,IAAI,QAAM;AAAA,IACV,GAAG;AAAA,IACH,SAAS,iBAAiB,EAAE,MAAM;AAAA,IAClC,YAAY,cAAc,EAAE,cAAc;AAAA,IAC1C,YAAY,cAAc,EAAE,gBAAgB,EAAE,MAAM;AAAA,EACrD,EAAE,EACD;AAAA,IAAI,OACJ,EAAE,OAAO,OACP,OAAO,OAAK,8BAAa,EAAE,cAAc,EAAE,EAAE,SAAS,CAAC,CAAC,EACxD,IAAI,OAAE;AAvCX;AAuCe;AAAA,QACV,GAAG;AAAA,QACH,OAAO;AAAA,QACP,OAAM,OAAE,SAAF,YAAU;AAAA,QAChB,QAAO,OAAE,UAAF,YAAW;AAAA,QAClB,UAAU,GAAG,EAAE,UAAU,IAAI,EAAE,IAAI;AAAA,QACnC,gBAAY,2BAAa,CAAC;AAAA,QAC1B,YAAY,WAAW,CAAC;AAAA,QACxB,gBAAgB;AAAA,MACjB;AAAA,KAAE;AAAA,EACJ,EACC,OAAO,CAAC,MAAM,SAAS,CAAC,GAAG,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC,EAC7C,IAAI,QAAG;AAnDV;AAmDc;AAAA,MACX,GAAG;AAAA,MACH,iBAAgB,2DAAkB,IAAI,gBAAgB,MAAtC,gBAA2C,mDAA0B;AAAA,IACtF;AAAA,GAAE;AAEH,SAAO,iBAAiB,OAAO,CAAC,MAAM,UAAU,EAAE,GAAG,MAAM,CAAC,KAAK,QAAQ,GAAG,KAAK,IAAI,CAAC,CAAC;AACxF;",
  "names": []
}
